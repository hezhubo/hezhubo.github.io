[{"title":"android多媒体播放器之VideoView","date":"2016-08-28T04:26:39.000Z","path":"2016/08/28/android-videoview/","text":"在需要播放视频的时候，我们会往往会直接使用VideoView，因为方便，简单几行代码就搞定了。 12345VideoView videoView; // 通过xml资源或是使用代码自行创建MediaController mediaController = new MediaController(this); // 封装了播放控制的一个布局（包含播放/暂停，时长显示，进度条等），this 上下文videoView.setMediaController(mediaController); // 设置控制器videoView.setVideoPath(&quot;/mnt/sdcard/test.mp4&quot;); // 视频路径，支持本地文件，http，rtsp协议videoView.start(); // 开始播放 VideoView其实是SurfaceView+MediaPlayer的封装，下面来分析一下源码的实现。 基于API 23的主要源码分析：结构关系12public class VideoView extends SurfaceView implements MediaPlayerControl, SubtitleController.Anchor &#123;&#125; 我们可以看到VideoView继承SurfaceView，实现了两接口：MediaPlayerControl和SubtitleController.Anchor。MediaPlayerControl就是android.widget.MediaController的内部接口，MediaController就是通过这个接口来控制播放器的。至于SubtitleController.Anchor这个接口是和字幕有关的，具体怎么用我暂时不清楚。下面看一下MediaPlayerControl的源码： 12345678910111213141516171819public interface MediaPlayerControl &#123; void start(); // 播放 void pause(); // 暂停 int getDuration(); // 获取总时长 int getCurrentPosition(); // 获取当前播放位置 void seekTo(int pos); // 跳转到指定位置 boolean isPlaying(); // 是否在播放 int getBufferPercentage(); // 获取总缓冲百分比 boolean canPause(); // 能否暂停 boolean canSeekBackward(); // 能否向后跳转 boolean canSeekForward(); // 能否向前跳转 /** * Get the audio session id for the player used by this VideoView. This can be used to * apply audio effects to the audio track of a video. * @return The audio session, or 0 if there was an error. */ int getAudioSessionId();&#125; 成员变量12345678910111213141516171819202122232425262728293031323334353637383940// settable by the clientprivate Uri mUri; // 视频的Uriprivate Map&lt;String, String&gt; mHeaders; // 请求头// 所有有可能的播放状态private static final int STATE_ERROR = -1; // 错误private static final int STATE_IDLE = 0; // 初始private static final int STATE_PREPARING = 1; // 预处理中private static final int STATE_PREPARED = 2; // 预处理完成private static final int STATE_PLAYING = 3; // 播放中private static final int STATE_PAUSED = 4; // 暂停private static final int STATE_PLAYBACK_COMPLETED = 5; // 播放完成private int mCurrentState = STATE_IDLE; // 当前状态private int mTargetState = STATE_IDLE; // 目标状态// All the stuff we need for playing and showing a videoprivate SurfaceHolder mSurfaceHolder = null; // Surface持有者private MediaPlayer mMediaPlayer = null; // 真正的播放器private int mAudioSession; // 音频 Session idprivate int mVideoWidth; // 视频宽private int mVideoHeight; // 视频高private int mSurfaceWidth; // 显示(绘制)宽private int mSurfaceHeight; // 显示(绘制)高private MediaController mMediaController; // 控制层控制器private OnCompletionListener mOnCompletionListener; // 播放完成监听器private MediaPlayer.OnPreparedListener mOnPreparedListener; // 预处理监听器private int mCurrentBufferPercentage; // 当前缓冲百分比 private OnErrorListener mOnErrorListener; // 错误监听器private OnInfoListener mOnInfoListener; // 播放(过程)信息监听器private int mSeekWhenPrepared; // 预处理完成跳转位置private boolean mCanPause; // 能否暂停private boolean mCanSeekBack; // 能否向后跳转private boolean mCanSeekForward; // 能否向前跳转/** Subtitle rendering widget overlaid on top of the video. */private RenderingWidget mSubtitleWidget; // 字幕渲染组件/** Listener for changes to subtitle data, used to redraw when needed. */private RenderingWidget.OnChangedListener mSubtitlesChangedListener; 初始化方法12345678910111213private void initVideoView() &#123; mVideoWidth = 0; mVideoHeight = 0; getHolder().addCallback(mSHCallback); // 给Holder添加回调 getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); // 这个可以不设置 setFocusable(true); // 设置可以获取焦点 setFocusableInTouchMode(true); // 设置触摸可以获取焦点 requestFocus(); // 请求焦点 mPendingSubtitleTracks = new Vector&lt;Pair&lt;InputStream, MediaFormat&gt;&gt;(); // 字幕相关 字幕轨道表 // 当前状态与目标状态均为初始状态 mCurrentState = STATE_IDLE; mTargetState = STATE_IDLE;&#125; 其中mSHCallback代码如下： 123456789101112131415161718192021222324252627282930SurfaceHolder.Callback mSHCallback = new SurfaceHolder.Callback()&#123; public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) &#123; // 在surface发生改变时回调此方法 mSurfaceWidth = w; // 设置surface宽 mSurfaceHeight = h; // 设置surface高 boolean isValidState = (mTargetState == STATE_PLAYING); // 若目标状态是播放状态，则记为有效状态 boolean hasValidSize = (mVideoWidth == w &amp;&amp; mVideoHeight == h); // 若视频宽高与surface宽高一致，则记为有效尺寸 if (mMediaPlayer != null &amp;&amp; isValidState &amp;&amp; hasValidSize) &#123; // 播放器可用，并且状态与尺寸均有效，则开始播放 if (mSeekWhenPrepared != 0) &#123; // 这是播放前检查是否要跳转 seekTo(mSeekWhenPrepared); // 跳转到指定位置 &#125; start(); // 开始播放 &#125; &#125; public void surfaceCreated(SurfaceHolder holder) &#123; // 在surface创建时回调此方法 mSurfaceHolder = holder; openVideo(); // 打开播放器 &#125; public void surfaceDestroyed(SurfaceHolder holder) &#123; // 在surface销毁时回调此方法，一旦销毁就不能再使用 mSurfaceHolder = null; if (mMediaController != null) mMediaController.hide(); // 隐藏控制层 release(true); // 释放资源 &#125;&#125;; SurfaceView测量部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 测量宽高 // 根据视频尺寸和布局宽高计算宽高 int width = getDefaultSize(mVideoWidth, widthMeasureSpec); int height = getDefaultSize(mVideoHeight, heightMeasureSpec); if (mVideoWidth &gt; 0 &amp;&amp; mVideoHeight &gt; 0) &#123; // 当视频宽高可用时 // 计算布局设定的大小 int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); // 下列条件父布局宽高是否限定子布局宽高 if (widthSpecMode == MeasureSpec.EXACTLY &amp;&amp; heightSpecMode == MeasureSpec.EXACTLY) &#123; // the size is fixed width = widthSpecSize; height = heightSpecSize; // for compatibility, we adjust size based on aspect ratio if ( mVideoWidth * height &lt; width * mVideoHeight ) &#123; //Log.i(&quot;@@@&quot;, &quot;image too wide, correcting&quot;); width = height * mVideoWidth / mVideoHeight; &#125; else if ( mVideoWidth * height &gt; width * mVideoHeight ) &#123; //Log.i(&quot;@@@&quot;, &quot;image too tall, correcting&quot;); height = width * mVideoHeight / mVideoWidth; &#125; &#125; else if (widthSpecMode == MeasureSpec.EXACTLY) &#123; // only the width is fixed, adjust the height to match aspect ratio if possible width = widthSpecSize; height = width * mVideoHeight / mVideoWidth; if (heightSpecMode == MeasureSpec.AT_MOST &amp;&amp; height &gt; heightSpecSize) &#123; // couldn&#x27;t match aspect ratio within the constraints height = heightSpecSize; &#125; &#125; else if (heightSpecMode == MeasureSpec.EXACTLY) &#123; // only the height is fixed, adjust the width to match aspect ratio if possible height = heightSpecSize; width = height * mVideoWidth / mVideoHeight; if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; width &gt; widthSpecSize) &#123; // couldn&#x27;t match aspect ratio within the constraints width = widthSpecSize; &#125; &#125; else &#123; // neither the width nor the height are fixed, try to use actual video size width = mVideoWidth; height = mVideoHeight; if (heightSpecMode == MeasureSpec.AT_MOST &amp;&amp; height &gt; heightSpecSize) &#123; // too tall, decrease both width and height height = heightSpecSize; width = height * mVideoWidth / mVideoHeight; &#125; if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; width &gt; widthSpecSize) &#123; // too wide, decrease both width and height width = widthSpecSize; height = width * mVideoHeight / mVideoWidth; &#125; &#125; &#125; else &#123; // no size yet, just adopt the given spec sizes &#125; setMeasuredDimension(width, height); // 存储测量的宽高&#125; 内部监听器视频尺寸变化监听器123456789101112MediaPlayer.OnVideoSizeChangedListener mSizeChangedListener = new MediaPlayer.OnVideoSizeChangedListener() &#123; public void onVideoSizeChanged(MediaPlayer mp, int width, int height) &#123; mVideoWidth = mp.getVideoWidth(); mVideoHeight = mp.getVideoHeight(); if (mVideoWidth != 0 &amp;&amp; mVideoHeight != 0) &#123; // 设置surface固定尺寸 getHolder().setFixedSize(mVideoWidth, mVideoHeight); requestLayout(); // 请求重新测量布局 &#125; &#125;&#125;; 视频预处理监听器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061MediaPlayer.OnPreparedListener mPreparedListener = new MediaPlayer.OnPreparedListener() &#123; public void onPrepared(MediaPlayer mp) &#123; mCurrentState = STATE_PREPARED; // 当前状态已预处理完成 // Get the capabilities of the player for this stream Metadata data = mp.getMetadata(MediaPlayer.METADATA_ALL, MediaPlayer.BYPASS_METADATA_FILTER); if (data != null) &#123; // 解析获取的视频信息 mCanPause = !data.has(Metadata.PAUSE_AVAILABLE) || data.getBoolean(Metadata.PAUSE_AVAILABLE); mCanSeekBack = !data.has(Metadata.SEEK_BACKWARD_AVAILABLE) || data.getBoolean(Metadata.SEEK_BACKWARD_AVAILABLE); mCanSeekForward = !data.has(Metadata.SEEK_FORWARD_AVAILABLE) || data.getBoolean(Metadata.SEEK_FORWARD_AVAILABLE); &#125; else &#123; // 视频信息获取失败，下面操作默认都可以 mCanPause = mCanSeekBack = mCanSeekForward = true; &#125; if (mOnPreparedListener != null) &#123; mOnPreparedListener.onPrepared(mMediaPlayer); // 告诉外部的监听器 &#125; if (mMediaController != null) &#123; mMediaController.setEnabled(true); // 当前控制器可用 &#125; mVideoWidth = mp.getVideoWidth(); mVideoHeight = mp.getVideoHeight(); int seekToPosition = mSeekWhenPrepared; // mSeekWhenPrepared may be changed after seekTo() call if (seekToPosition != 0) &#123; seekTo(seekToPosition); // 跳转到指定位置 &#125; if (mVideoWidth != 0 &amp;&amp; mVideoHeight != 0) &#123; getHolder().setFixedSize(mVideoWidth, mVideoHeight); // 设置surface固定尺寸 if (mSurfaceWidth == mVideoWidth &amp;&amp; mSurfaceHeight == mVideoHeight) &#123; // We didn&#x27;t actually change the size (it was already at the size // we need), so we won&#x27;t get a &quot;surface changed&quot; callback, so // start the video here instead of in the callback. if (mTargetState == STATE_PLAYING) &#123; // 当目标状态为播放状态时 start(); // 开始播放 if (mMediaController != null) &#123; mMediaController.show(); // 展示控制器UI &#125; &#125; else if (!isPlaying() &amp;&amp; (seekToPosition != 0 || getCurrentPosition() &gt; 0)) &#123; // 不是在播放状态并且当前进度不为0时，展示控制器UI if (mMediaController != null) &#123; // Show the media controls when we&#x27;re paused into a video and make &#x27;em stick. mMediaController.show(0); &#125; &#125; &#125; &#125; else &#123; // We don&#x27;t know the video size yet, but should start anyway. // The video size might be reported to us later. if (mTargetState == STATE_PLAYING) &#123; // 当目标状态为播放状态时 start(); // 开始播放 &#125; &#125; &#125;&#125;; 视频播放完成监听器1234567891011121314private MediaPlayer.OnCompletionListener mCompletionListener = new MediaPlayer.OnCompletionListener() &#123; public void onCompletion(MediaPlayer mp) &#123; // 当前状态与目标状态为播放完成状态 mCurrentState = STATE_PLAYBACK_COMPLETED; mTargetState = STATE_PLAYBACK_COMPLETED; if (mMediaController != null) &#123; mMediaController.hide(); // 隐藏控制层 &#125; if (mOnCompletionListener != null) &#123; mOnCompletionListener.onCompletion(mMediaPlayer); // 通知外部的监听器 &#125; &#125;&#125;; 视频播放(过程)信息监听器12345678910private MediaPlayer.OnInfoListener mInfoListener = new MediaPlayer.OnInfoListener() &#123; public boolean onInfo(MediaPlayer mp, int arg1, int arg2) &#123; // 这里没做任何处理，直接通知外部的监听器 if (mOnInfoListener != null) &#123; mOnInfoListener.onInfo(mp, arg1, arg2); &#125; return true; &#125;&#125;; 视频播放错误监听器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private MediaPlayer.OnErrorListener mErrorListener = new MediaPlayer.OnErrorListener() &#123; public boolean onError(MediaPlayer mp, int framework_err, int impl_err) &#123; Log.d(TAG, &quot;Error: &quot; + framework_err + &quot;,&quot; + impl_err); // 当前状态与目标状态为错误状态 mCurrentState = STATE_ERROR; mTargetState = STATE_ERROR; if (mMediaController != null) &#123; mMediaController.hide(); // 隐藏控制层UI &#125; /* If an error handler has been supplied, use it and finish. */ if (mOnErrorListener != null) &#123; if (mOnErrorListener.onError(mMediaPlayer, framework_err, impl_err)) &#123; // 通知外部的监听器，又外部来处理错误，不往下执行 return true; &#125; &#125; /* Otherwise, pop up an error dialog so the user knows that * something bad has happened. Only try and pop up the dialog * if we&#x27;re attached to a window. When we&#x27;re going away and no * longer have a window, don&#x27;t bother showing the user an error. */ if (getWindowToken() != null) &#123; Resources r = mContext.getResources(); int messageId; if (framework_err == MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK) &#123; messageId = com.android.internal.R.string.VideoView_error_text_invalid_progressive_playback; &#125; else &#123; messageId = com.android.internal.R.string.VideoView_error_text_unknown; &#125; new AlertDialog.Builder(mContext) .setMessage(messageId) .setPositiveButton(com.android.internal.R.string.VideoView_error_button, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; /* If we get here, there is no onError listener, so * at least inform them that the video is over. */ if (mOnCompletionListener != null) &#123; mOnCompletionListener.onCompletion(mMediaPlayer); &#125; &#125; &#125;) .setCancelable(false) .show(); &#125; return true; &#125;&#125;; 视频缓冲监听器123456private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener = new MediaPlayer.OnBufferingUpdateListener() &#123; public void onBufferingUpdate(MediaPlayer mp, int percent) &#123; mCurrentBufferPercentage = percent; // 记录当前缓冲百分比 &#125;&#125;; 触碰及键盘事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; // 触摸事件 if (isInPlaybackState() &amp;&amp; mMediaController != null) &#123; // 当前状态为可用状态并且控制器存在 toggleMediaControlsVisiblity(); // 显示/隐藏控制层UI &#125; return false;&#125;@Overridepublic boolean onTrackballEvent(MotionEvent ev) &#123; // 轨迹球事件 if (isInPlaybackState() &amp;&amp; mMediaController != null) &#123; // 当前状态为可用状态并且控制器存在 toggleMediaControlsVisiblity(); // 显示/隐藏控制层UI &#125; return false;&#125;/** * 判断是否为可用状态 * 播放器不为空 * 当前状态不为错误，初始，预处理中 */private boolean isInPlaybackState() &#123; return (mMediaPlayer != null &amp;&amp; mCurrentState != STATE_ERROR &amp;&amp; mCurrentState != STATE_IDLE &amp;&amp; mCurrentState != STATE_PREPARING);&#125;@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event)&#123; // 主要是用于显示/隐藏控制器UI,以及处理播放暂停 // 判断按键是否为需要处理的按键 boolean isKeyCodeSupported = keyCode != KeyEvent.KEYCODE_BACK &amp;&amp; keyCode != KeyEvent.KEYCODE_VOLUME_UP &amp;&amp; keyCode != KeyEvent.KEYCODE_VOLUME_DOWN &amp;&amp; keyCode != KeyEvent.KEYCODE_VOLUME_MUTE &amp;&amp; keyCode != KeyEvent.KEYCODE_MENU &amp;&amp; keyCode != KeyEvent.KEYCODE_CALL &amp;&amp; keyCode != KeyEvent.KEYCODE_ENDCALL; if (isInPlaybackState() &amp;&amp; isKeyCodeSupported &amp;&amp; mMediaController != null) &#123; if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) &#123; if (mMediaPlayer.isPlaying()) &#123; pause(); mMediaController.show(); &#125; else &#123; start(); mMediaController.hide(); &#125; return true; &#125; else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) &#123; if (!mMediaPlayer.isPlaying()) &#123; start(); mMediaController.hide(); &#125; return true; &#125; else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) &#123; if (mMediaPlayer.isPlaying()) &#123; pause(); mMediaController.show(); &#125; return true; &#125; else &#123; toggleMediaControlsVisiblity(); &#125; &#125; return super.onKeyDown(keyCode, event);&#125;/** * 控制器UI显示与隐藏相互切换 */private void toggleMediaControlsVisiblity() &#123; if (mMediaController.isShowing()) &#123; mMediaController.hide(); &#125; else &#123; mMediaController.show(); &#125;&#125; 主要操作方法设置视频源路径123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/** * Sets video path. * * @param path the path of the video. */public void setVideoPath(String path) &#123; setVideoURI(Uri.parse(path));&#125;/** * Sets video URI. * * @param uri the URI of the video. */public void setVideoURI(Uri uri) &#123; setVideoURI(uri, null);&#125;/** * Sets video URI using specific headers. * * @param uri the URI of the video. * @param headers the headers for the URI request. * Note that the cross domain redirection is allowed by default, but that can be * changed with key/value pairs through the headers parameter with * &quot;android-allow-cross-domain-redirect&quot; as the key and &quot;0&quot; or &quot;1&quot; as the value * to disallow or allow cross domain redirection. */public void setVideoURI(Uri uri, Map&lt;String, String&gt; headers) &#123; mUri = uri; // 设置视频的Uri mHeaders = headers; // 设置请求头 mSeekWhenPrepared = 0; // 设置预处理完成不跳转 openVideo(); // 打开播放器并设置相应参数 requestLayout(); // 请求重新测量布局 invalidate(); // 请求重绘&#125;/** * 最重要的方法————开启视频 * 初始化MediaPlayer及其参数 */private void openVideo() &#123; if (mUri == null || mSurfaceHolder == null) &#123; // not ready for playback just yet, will try again later return; &#125; // we shouldn&#x27;t clear the target state, because somebody might have // called start() previously release(false); // 不改变状态地释放资源 // 获取音频管理器并请求获得音频焦点，销毁时需要释放焦点 AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE); am.requestAudioFocus(null, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN); try &#123; mMediaPlayer = new MediaPlayer(); // 以下设置字幕相关的 // TODO: create SubtitleController in MediaPlayer, but we need // a context for the subtitle renderers final Context context = getContext(); final SubtitleController controller = new SubtitleController( context, mMediaPlayer.getMediaTimeProvider(), mMediaPlayer); controller.registerRenderer(new WebVttRenderer(context)); controller.registerRenderer(new TtmlRenderer(context)); controller.registerRenderer(new ClosedCaptionRenderer(context)); mMediaPlayer.setSubtitleAnchor(controller, this); // 设置音频的SessionId if (mAudioSession != 0) &#123; mMediaPlayer.setAudioSessionId(mAudioSession); &#125; else &#123; mAudioSession = mMediaPlayer.getAudioSessionId(); &#125; // 设置各监听器 mMediaPlayer.setOnPreparedListener(mPreparedListener); mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener); mMediaPlayer.setOnCompletionListener(mCompletionListener); mMediaPlayer.setOnErrorListener(mErrorListener); mMediaPlayer.setOnInfoListener(mInfoListener); mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener); mCurrentBufferPercentage = 0; // 缓冲进度为0 mMediaPlayer.setDataSource(mContext, mUri, mHeaders); // 设置播放地址等参数 mMediaPlayer.setDisplay(mSurfaceHolder); // 设置Surface持有者，用于绘制视频 mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC); // 设置音频流类型 mMediaPlayer.setScreenOnWhilePlaying(true); // 设置当播放保持屏幕高亮 mMediaPlayer.prepareAsync(); // 开始异步预处理 // 添加字幕流 for (Pair&lt;InputStream, MediaFormat&gt; pending: mPendingSubtitleTracks) &#123; try &#123; mMediaPlayer.addSubtitleSource(pending.first, pending.second); &#125; catch (IllegalStateException e) &#123; mInfoListener.onInfo( mMediaPlayer, MediaPlayer.MEDIA_INFO_UNSUPPORTED_SUBTITLE, 0); &#125; &#125; // we don&#x27;t set the target state here either, but preserve the // target state that was there before. mCurrentState = STATE_PREPARING; // 当前为预处理中状态 attachMediaController(); // 添加控制器（若没有设置，则不添加） &#125; catch (IOException ex) &#123; Log.w(TAG, &quot;Unable to open content: &quot; + mUri, ex); mCurrentState = STATE_ERROR; mTargetState = STATE_ERROR; mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0); return; &#125; catch (IllegalArgumentException ex) &#123; Log.w(TAG, &quot;Unable to open content: &quot; + mUri, ex); mCurrentState = STATE_ERROR; mTargetState = STATE_ERROR; mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0); return; &#125; finally &#123; mPendingSubtitleTracks.clear(); &#125;&#125;/* * release the media player in any state */private void release(boolean cleartargetstate) &#123; if (mMediaPlayer != null) &#123; mMediaPlayer.reset(); // 重置播放器 mMediaPlayer.release(); // 是否播放器 mMediaPlayer = null; mPendingSubtitleTracks.clear(); // 释放字幕 mCurrentState = STATE_IDLE; // 当前状态为初始状态 if (cleartargetstate) &#123; // 需要清楚目标状态 mTargetState = STATE_IDLE; // 目标状态为初始状态 &#125; AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE); am.abandonAudioFocus(null); // 释放音频焦点 &#125;&#125; 播放12345678@Overridepublic void start() &#123; if (isInPlaybackState()) &#123; // 播放器可以时 mMediaPlayer.start(); // 开始播放 mCurrentState = STATE_PLAYING; // 当前状态为播放状态 &#125; mTargetState = STATE_PLAYING; // 目标状态为播放状态&#125; 暂停12345678910@Overridepublic void pause() &#123; if (isInPlaybackState()) &#123; // 播放器可以时 if (mMediaPlayer.isPlaying()) &#123; // 正在播放 mMediaPlayer.pause(); // 暂停 mCurrentState = STATE_PAUSED; // 当前状态为暂停状态 &#125; &#125; mTargetState = STATE_PAUSED; // 目标状态为暂停状态&#125; 挂起播放器1234// 此方法一般在Activity进入onStop()状态时调用，不改变状态地释放资源public void suspend() &#123; release(false);&#125; 恢复播放器1234// 此方法一般在Activity从后台调到前台进入onResume()状态时调用public void resume() &#123; openVideo();&#125; 其他方法12345int getDuration() // 获取时长int getCurrentPosition() // 获取当前播放进度void seekTo(int msec) // 跳转到指定位置boolean isPlaying() // 视频是否在播放getBufferPercentage() // 获取缓冲百分比 其他 控制器UI加入 及 字幕相关 等方法就不一一分析了。可以自行查看VideoView源码","tags":[{"name":"音视频","slug":"音视频","permalink":"http://hezhubo.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"videoview","slug":"videoview","permalink":"http://hezhubo.github.io/tags/videoview/"},{"name":"多媒体","slug":"多媒体","permalink":"http://hezhubo.github.io/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"}]},{"title":"android多媒体播放器之MediaPlayer","date":"2016-08-27T12:24:15.000Z","path":"2016/08/27/android-mediaplayer/","text":"废话少说，先上一张无比重要的图：MediaPlayer状态图，读懂此图那后面的都是废话了。 android官方MediaPlayer状态图 MediaPlayer的简单使用12345678MediaPlayer mediaPlayer = new MediaPlayer();try &#123; mediaPlayer.setDataSource(&quot;/mnt/sdcard/test.mp3&quot;); // 设置多媒体文件路径，支持本地文件，http，rtsp协议 mediaPlayer.prepare(); // 以同步(阻塞)方式，预处理（加载）多媒体文件，此方法一般用于本地文件 mediaPlayer.start(); // 开始播放&#125; catch (IOException e) &#123; e.printStackTrace();&#125; MediaPlayer的基本方法说明创建MediaPlayer对象123456789101112131415// 基本的构造方法MediaPlayer mediaPlayer = new MediaPlayer();// 静态的构造方法Context context; // 上下文Uri uri; // 多媒体文件的URISurfaceHolder holder; // surface持有者，用于视频画面输出AudioAttributes audioAttributes; // 封装音频流信息的属性集合类int audioSessionId; // 音频的Session Idint resid; // 多媒体资源IdMediaPlayer mediaPlayer = MediaPlayer.create(context, uri);MediaPlayer mediaPlayer = MediaPlayer.create(context, uri, holder);MediaPlayer mediaPlayer = MediaPlayer.create(context, uri, holder, audioAttributes, audioSessionId);MediaPlayer mediaPlayer = MediaPlayer.create(context, resid);MediaPlayer mediaPlayer = MediaPlayer.create(context, resid, audioAttributes, audioSessionId); 设置MediaPlayer的各种监听器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 预处理监听器mediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mp) &#123; // 在MediaPlayer完成加载多媒体文件时回调此方法 // 此时可以获取多媒体文件信息（如视频宽高，时长等） // 可以开始执行播放 &#125;&#125;);// 播放完成监听器mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mp) &#123; // 在MediaPlayer播放完成时回调此方法 &#125;&#125;);// 播放出错监听器mediaPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener() &#123; @Override public boolean onError(MediaPlayer mp, int what, int extra) &#123; // 使用播放器过程中出现错误会回调此方法 // what 发生的错误类型, extra 具体的错误代码 return false; &#125;&#125;);// 播放过程中部分信息监听器mediaPlayer.setOnInfoListener(new MediaPlayer.OnInfoListener() &#123; @Override public boolean onInfo(MediaPlayer mp, int what, int extra) &#123; // 在播放器播放过程中部分状态信息会回调此方法 // what 信息或警告的类型, extra 具体的信息代码 // 如 what: MEDIA_INFO_BUFFERING_START 开始缓冲 // MEDIA_INFO_BUFFERING_END 缓冲完成 return false; &#125;&#125;);// 视频尺寸变化监听器mediaPlayer.setOnVideoSizeChangedListener(new MediaPlayer.OnVideoSizeChangedListener() &#123; @Override public void onVideoSizeChanged(MediaPlayer mp, int width, int height) &#123; // 在播放视频时视频宽高发生变化回调此方法 // 此时一般会去处理视频输出的View的宽高布局 &#125;&#125;);// 缓冲进度更新监听器mediaPlayer.setOnBufferingUpdateListener(new MediaPlayer.OnBufferingUpdateListener() &#123; @Override public void onBufferingUpdate(MediaPlayer mp, int percent) &#123; // 在缓冲进度改变时会回调此方法 // percent 缓冲百分比 // 一般用于更新进度条的第二进度 &#125;&#125;);// 播放跳转完成监听器mediaPlayer.setOnSeekCompleteListener(new MediaPlayer.OnSeekCompleteListener() &#123; @Override public void onSeekComplete(MediaPlayer mp) &#123; // 在调用seekTo()，跳转完成后会回调此方法 &#125;&#125;);// 字幕监听器mediaPlayer.setOnTimedTextListener(new MediaPlayer.OnTimedTextListener() &#123; @Override public void onTimedText(MediaPlayer mp, TimedText text) &#123; // 当有字幕需要显示时会回调此方法 // text 包含字幕内容，格式 // 我暂时没有用过此监听器 &#125;&#125;);// API23 媒体数据可用监听器mediaPlayer.setOnTimedMetaDataAvailableListener(new MediaPlayer.OnTimedMetaDataAvailableListener() &#123; @Override public void onTimedMetaDataAvailable(MediaPlayer mp, TimedMetaData data) &#123; // 当有可用的元数据时回调此方法 // data 数据元，包含时间戳 // 我暂时没有用过此监听器，我猜想可以用此回调来实现边看边缓存视频 &#125;&#125;); MediaPlayer的操作方法设置数据元1234567891011121314Context context; // 上下文Uri uri; // 多媒体文件的URIMap&lt;String, String&gt; headers; // http的请求头String path; // 多媒体路径，支持本地文件，http，rtsp协议FileDescriptor fd; // 多媒体文件描述符，可通过AssetManager去构建long offset; // 以字节为单位的数据偏移量long length; // 要播放的数据字节长度MediaDataSource dataSource; // 为framework层提供媒体数据的类mediaPlayer.setDataSource(context, uri);mediaPlayer.setDataSource(context, uri, headers); // 暂时没用过mediaPlayer.setDataSource(path);mediaPlayer.setDataSource(fd);mediaPlayer.setDataSource(fd, offset, length); // 暂时没用过mediaPlayer.setDataSource(dataSource); // 暂时没用过 预处理(加载)多媒体数据12mediaPlayer.prepare(); // 会阻塞当前线程mediaPlayer.prepareAsync(); // 异步加载 开始播放1mediaPlayer.start(); // 需要在预处理完成后才会起作用 暂停播放1mediaPlayer.pause(); // 需要在预处理完成后才会起作用 跳转到指定位置12int msec; // 跳转位置（单位毫秒） 取值要大于0，小于视频总时长mediaPlayer.seekTo(msec); // 需要在预处理完成后才会起作用 获取当前播放位置1int currentPosition = mediaPlayer.getCurrentPosition(); // 需要在预处理完成后才会起作用 获取当前总时长1int duration = mediaPlayer.getDuration(); // 需要在预处理完成后才会起作用 停止播放1mediaPlayer.stop(); // 需要在预处理完成后才会起作用，若想继续播放，需要重新加载多媒体文件 重置播放器1mediaPlayer.reset(); // 重置mediaPlayer为最初状态，再次使用需要重新设置多媒体路径 释放资源1mediaPlayer.release(); // 释放与mediaPlayer对象关联的所有资源 设置视频画面输出12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 通过SurfaceView来显示视频SurfaceView surfaceView; // 通过xml资源或是使用代码自行创建// 需要给surface持有者添加监听器surfaceView.getHolder().addCallback(new SurfaceHolder.Callback() &#123; @Override public void surfaceCreated(SurfaceHolder holder) &#123; // surfaceView成功创建，此时holder才可用 mediaPlayer.setDisplay(holder); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; // surface发生改变时 // format 格式， width 宽， height 高 &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; // surfaceView销毁时 &#125;&#125;);// 通过TextureView来显示视频TextureView textureView; // 通过xml资源或是使用代码自行创建textureView.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() &#123; @Override public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) &#123; // 当SurfaceTexture可用时 // width 纹理宽， height 纹理高 Surface displaySurface = new Surface(surface); // 通过SurfaceTexture来构建Surface mediaPlayer.setSurface(displaySurface); &#125; @Override public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) &#123; // 纹理尺寸发生改变时 &#125; @Override public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) &#123; // textureView销毁时 return false; &#125; @Override public void onSurfaceTextureUpdated(SurfaceTexture surface) &#123; // textureView重新设置了SurfaceTexture &#125;&#125;); 获取视频宽高12int width = mediaPlayer.getVideoWidth(); // 需要在预处理完成后才会起作用int height = mediaPlayer.getVideoHeight(); // 需要在预处理完成后才会起作用 其他方法就不一一列出了，可以自行查看MediaPlayer源码","tags":[{"name":"音视频","slug":"音视频","permalink":"http://hezhubo.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"多媒体","slug":"多媒体","permalink":"http://hezhubo.github.io/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"},{"name":"mediaplayer","slug":"mediaplayer","permalink":"http://hezhubo.github.io/tags/mediaplayer/"}]},{"title":"ADB常用命令","date":"2016-07-06T15:35:56.000Z","path":"2016/07/06/android-adb-command/","text":"常用命令adb帮助1adb help 启动adb服务1adb start-server 终止adb服务1adb kill-server 显示当前运行的全部设备1adb devices [-l] // [-l] 显示设备详细信息 对某一设备执行命令1adb -s &lt;specific device&gt; // &lt;specific device&gt; 设备ID 重启设备1adb reboot 以网络方式连接设备1adb connect &lt;host&gt;[:&lt;port&gt;] // 设备ip+端口 默认5555 断开网络设备1adb disconnect [&lt;host&gt;[:&lt;port&gt;]] // 设备ip+端口 默认5555 安装（覆盖）应用1adb install -r &lt;file&gt; // &lt;file&gt; apk路径 卸载应用1adb uninstall &lt;package&gt; // &lt;package&gt; 应用包名 传输文件到设备1adb push &lt;local&gt;... &lt;remote&gt; // &lt;local&gt; 本地文件路径 &lt;remote&gt; 设备保存路径 拉取设备文件到电脑1adb pull &lt;remote&gt;... &lt;local&gt; // &lt;local&gt; 电脑保存路径 &lt;remote&gt; 设备文件路径 打印日志12adb logcat --help // logcat帮助adb logcat [options] [filterspecs] // [options] [filterspecs] 过滤参数 清除缓冲区日志1adb logcat -c 输出日志到文件12adb logcat -f &lt;filename&gt; // &lt;filename&gt;文件路径(手机上的路径)adb logcat -d -f &lt;filename&gt; // 边输出到屏幕，边保存 指定日志输出格式12adb logcat -v time // 带时间的输出adb logcat -v threadtime // 带时间和线程信息 过滤标签12adb logcat -s hezb // 过滤TAG为 hezb 的所以logadb logcat -s hezb System.out // 过滤多个TAG(hezb, System.out) 按等级过滤 优先级从低到高：Log.v - VERBOSE : 黑色Log.d - DEBUG : 蓝色Log.i - INFO : 绿色Log.w - WARN : 橙色Log.e - ERROR : 红色 123adb logcat *:D // 过滤Debug以上优先级的logadb logcat hezb:D *:S // 过滤TAG为 hezb Debug以上优先级的log,没有 *:S 则无法正确输出adb logcat hezb:D test:I *:S // 过滤多个TAG(hezb,test),并且各自优先级可选 使用系统命令过滤12adb logcat | grep &quot;hezb&quot; // linux 使用 grep 命令，详细过滤看grep用法adb logcat | find &quot;hezb&quot; // windows 使用 find 命令 登陆设备12adb shell // 普通用户权限adb root // root用户权限(需要手机已经root) shell权限下1su // 切换成root用户(需要手机已经root) root权限下12mount -o remount / // 挂载 系统文件夹 到当前目录rm xxx.apk // 删除系统应用 模拟键盘鼠标事件123input keyevent &lt;value&gt; // 模拟键盘按键 value对应键盘键值sendevent [device] [type] [code] [value] // 全事件，需要多个组合使用 device: /dev/input/event0 getevent // 监听当前手机事件 键盘事件表 KeyEvent Value KEYCODE 0 KEYCODE_UNKNOWN 1 KEYCODE_MENU 2 KEYCODE_SOFT_RIGHT 3 KEYCODE_HOME 4 KEYCODE_BACK 5 KEYCODE_CALL 6 KEYCODE_ENDCALL 7 KEYCODE_0 8 KEYCODE_1 9 KEYCODE_2 10 KEYCODE_3 11 KEYCODE_4 12 KEYCODE_5 13 KEYCODE_6 14 KEYCODE_7 15 KEYCODE_8 16 KEYCODE_9 17 KEYCODE_STAR 18 KEYCODE_POUND 19 KEYCODE_DPAD_UP 20 KEYCODE_DPAD_DOWN 21 KEYCODE_DPAD_LEFT 22 KEYCODE_DPAD_RIGHT 23 KEYCODE_DPAD_CENTER 24 KEYCODE_VOLUME_UP 25 KEYCODE_VOLUME_DOWN 26 KEYCODE_POWER 27 KEYCODE_CAMERA 28 KEYCODE_CLEAR 29 KEYCODE_A 30 KEYCODE_B 31 KEYCODE_C 32 KEYCODE_D 33 KEYCODE_E 34 KEYCODE_F 35 KEYCODE_G 36 KEYCODE_H 37 KEYCODE_I 38 KEYCODE_J 39 KEYCODE_K 40 KEYCODE_L 41 KEYCODE_M 42 KEYCODE_N 43 KEYCODE_O 44 KEYCODE_P 45 KEYCODE_Q 46 KEYCODE_R 47 KEYCODE_S 48 KEYCODE_T 49 KEYCODE_U 50 KEYCODE_V 51 KEYCODE_W 52 KEYCODE_X 53 KEYCODE_Y 54 KEYCODE_Z 55 KEYCODE_COMMA 56 KEYCODE_PERIOD 57 KEYCODE_ALT_LEFT 58 KEYCODE_ALT_RIGHT 59 KEYCODE_SHIFT_LEFT 60 KEYCODE_SHIFT_RIGHT 61 KEYCODE_TAB 62 KEYCODE_SPACE 63 KEYCODE_SYM 64 KEYCODE_EXPLORER 65 KEYCODE_ENVELOPE 66 KEYCODE_ENTER 67 KEYCODE_DEL 68 KEYCODE_GRAVE 69 KEYCODE_MINUS 70 KEYCODE_EQUALS 71 KEYCODE_LEFT_BRACKET 72 KEYCODE_RIGHT_BRACKET 73 KEYCODE_BACKSLASH 74 KEYCODE_SEMICOLON 75 KEYCODE_APOSTROPHE 76 KEYCODE_SLASH 77 KEYCODE_AT 78 KEYCODE_NUM 79 KEYCODE_HEADSETHOOK 80 KEYCODE_FOCUS 81 KEYCODE_PLUS 82 KEYCODE_MENU 83 KEYCODE_NOTIFICATION 84 KEYCODE_SEARCH 85 TAG_LAST_KEYCODE","tags":[{"name":"android","slug":"android","permalink":"http://hezhubo.github.io/tags/android/"},{"name":"adb","slug":"adb","permalink":"http://hezhubo.github.io/tags/adb/"}]},{"title":"FFmpeg 常用命令","date":"2016-07-05T01:35:34.000Z","path":"2016/07/05/FFmpeg-command/","text":"常用命令分离视频音频流12ffmpeg -i input_file -vcodec copy -an output_file_video // 分离视频流ffmpeg -i input_file -acodec copy -vn output_file_audio // 分离音频流 视频裁剪1ffmpeg -ss 0:1:30 -t 0:0:20 -i input.mp4 -vcodec copy -acodec copy output.mp4 // 时间格式可以是 00:00:00.000 或 x.xxx(单位秒) 视频合成123ffmpeg -i &quot;1.mp4&quot; -vcodec copy -acodec copy -vbsf h264_mp4toannexb &quot;1.ts&quot;ffmpeg -i &quot;2.mp4&quot; -vcodec copy -acodec copy -vbsf h264_mp4toannexb &quot;2.ts&quot;ffmpeg -i &quot;concat:1.ts|2.ts&quot; -acodec copy -vcodec copy -absf aac_adtstoasc &quot;output.mp4&quot; // 若只有1个ts,不需要concat: 视频截图12ffmpeg -i &quot;input.mp4&quot; -r 2 -start_number 1 -vframes 10 -s 60x60 &quot;thumb_%d.jpg&quot; // 连续截取图片，设置帧率为2fps，截取10张，也就是截取了5秒的视频截图，截图保存的名称的第一张为thumb_1.jpg，往后自动累加ffmpeg -ss 00:56 -i &quot;input.mp4&quot; -f image2 -s 100x100 &quot;thumb.jpg&quot; // 截取指定时间（00:56）的画面 视频录制1ffmpeg -i &quot;rtmp://192.168.1.100:1935/live/demo&quot; –vcodec copy &quot;output.mp4&quot; YUV序列播放1ffplay -f rawvideo -video_size 1920x1080 input.yuv YUV序列转AVI1ffmpeg –s w*h –pix_fmt yuv420p –i input.yuv –vcodec mpeg4 output.avi // w/h 视频宽/高 加水印1ffmpeg -i input.mp4 -i logo.png -filter_complex &quot;overlay=10:5&quot; out.mp4 // 左上角 距离 左边距 10 上边距 5 overlay参数:左上角为 overlay&#x3D;10:5 &#x2F;&#x2F; 左边 10 上边 5右上角为 overlay&#x3D;main_w-overlay_w-10:5 &#x2F;&#x2F; 右边 10 上边 5右下角为 overlay&#x3D;main_w-overlay_w-10:main_h-overlay_h-5 &#x2F;&#x2F; 右边 10 下边 5左下角为 overlay&#x3D;10: main_h-overlay_h-5 &#x2F;&#x2F; 左边 10 上边 5 常用参数说明主要参数： -i 设定输入流 -f 设定输出格式 -ss 开始时间 -t 持续时间 -y 覆盖输出文件 视频参数： -aspect 设定画面的比例 -b 设定视频流量，默认为200Kbit&#x2F;s -bitexact 使用标准比特率 -r 设定帧速率，默认为25 -s 设定画面的宽与高 -title 设置标题 -vn 不处理视频 -vcodec 设定视频编解码器，未设定时则使用与输入流相同的编解码器 -vframes 设置转换多少帧(frame)的视频 -qscale 视频质量，取值0.01-255，约小质量越好 -qmin 设定最小质量，与-qmax（设定最大质量）共用，比如-qmin 10 -qmax 31 -sameq 使用和源同样的质量 音频参数： -ar 设定采样率 -ac 设定声音的Channel数 -acodec 设定声音编解码器，未设定时则使用与输入流相同的编解码器 -ab 设定声音比特率 -an 不处理音频 -vol 设定音量&lt;百分比&gt;，200即原来的2倍","tags":[{"name":"音视频","slug":"音视频","permalink":"http://hezhubo.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://hezhubo.github.io/tags/FFmpeg/"}]},{"title":"解决ADB 5037端口 被外部程序占用问题","date":"2016-07-04T16:44:52.000Z","path":"2016/07/05/android-adb-prot-occupied/","text":"windows环境下： 1netstat -ano | findstr &quot;5037&quot; 结果： TCP 127.0.0.1:5037 0.0.0.0:0 LISTENING 1408 … 查看哪个进程占用了 1tasklist | findstr &quot;1408&quot; 结果：SogouPhoneService.exe 1408 Console 1 8,836 K 原来是SogouPhoneService进程占了adb的端口 用命令或打开任务管理器终止掉该进程就可以了。 再执行 1adb devices OK!!!","tags":[{"name":"android","slug":"android","permalink":"http://hezhubo.github.io/tags/android/"},{"name":"adb","slug":"adb","permalink":"http://hezhubo.github.io/tags/adb/"}]}]